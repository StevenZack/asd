目录

- [绪论](#绪论)
- [需求分析](#需求分析)
- [系统总体设计](#系统总体设计)
- [开发与实现](#开发与实现)
- [总结](#总结)
- [参考文献](#参考文献)
- [致谢](#致谢)
- [外文原文](#外文原文)
- [中文翻译](#中文翻译)

# 绪论

## 项目开发背景

聊天室App能为人们的交流和联系提供一个平台。通过完善的网上聊天系统的管理，可以达到增进人与人之间、商家与客户之间、消费者与消费者之间的交流和联系的目的。聊天室是一个通过国际互联信息网络进行多人通讯的系统。在这个信息及其发达的时代，目前我们可以利用电话、电子邮件、微信等工具来进行通讯和联系。这些东西或多或少都有一些自身的缺陷。比如说电话就是一种非常昂贵的通讯手段，虽然说前一段时间，李总理在大会上提出了提速降费的战略方针，但是通讯运营商依然没有将通讯的费用降下来。政府的政策并没有多大的作用。特别是在互联网时代，电话费事费钱而且在特定条件下交流的效果不一定好，如今使用电话的人越来越少了，人们更加喜欢通过互联网来与朋友进行沟通和交流与工作。鉴于以上现状，我觉得自己有必要学习并研究一下互联网聊天技术的原理和实现了。

因为每天在学校，打开手机使用次数最多的就是QQ，对QQ比较了解，所以一直是想自己制作一款类似的聊天软件。
开发这一款聊天室App的目的并不是为了商用或者普及到用户端去，因为本人以前也没有IM类应用的开发的经验，因为对聊天室这方面的知识和技术比较感兴趣，所以打算接着这次机会，深入研究一下如何实现一个自己的聊天室App、需要用到一些什么技术、消息到底是如何传输的？这一系列的问题将带领我编写一款自己的聊天室App。

## 项目简介

本项目将Go语言和Android Studio来编写一款现代的运行在安卓平台的聊天室App。通讯协议我们将使用WebSocket技术，同时也会用到一些HTTP协议来处理一些无状态请求。
其主要的功能有创建房间、修改本机用户名、进入聊天室、在聊天室中发送消息与接收消息等。

## 国内外现状

如今，网络聊天室已经没有互联网刚刚兴起那个时候火了，其主要原因是人们对于陌生人社交越来越失去兴趣，对于聊天对象的要求越来越高。不像当年，聊天室对于人们还是一个非常新奇的事物，能连上互联网已经是非常令人兴奋的事情了，更何况在互联网上与一个从来都没有见过面的陌生人聊天了。那个时候最火的聊天社区是天涯，人们在聊天室里面无话不谈，遇到志趣相投的人甚至能聊上一整天。

但是，随着移动互联网的普及，互联网对于人们来说已经不是什么新事物了，最大的变化，不过是把互联网从庞大昂贵且笨重的电脑搬到体积小巧的智能手机上来了而已。人们对于聊天室没有了当年的热情，不再热衷于陌生人社交。因为人人都能上网，互联网上的网民参差不齐，人们对于陌生人社交开始厌烦，开始更多的精力和心思用来维护熟人之间的社交。也正是这个节骨眼，诞生了一个能够载入互联网史册的熟人社交App：微信。

## 应用场景


# 需求分析

## 目标分析

## 功能分析

本系统的主要功能是给用户提供一个即开即用的聊天室以供聊天用。

## 主要技术

WebSocket技术、Go语言、Android Studio。

# 系统总体设计

## 系统总体设计

系统总体设计主要分为：服务端、客户端、数据结构、通讯协议

## 服务端

服务端由多个HTTP接口和一个WebSocket长连接组成。

HTTP接口用于处理一些无状态的请求，一共提供五个主要功能：用户登录、用户注册、获取房间列表、删除房间和获取房间在线人数。

用户登录传入参数为用户名和密码，客户端发生请求过来之后，服务器开始在数据库中查找该用户名和密码，如果存在则登录成功，不存在则登录失败。

用户注册和用户登录类似，传入参数为用户名和密码。一旦用户发送请求过来以后，服务器先向数据库查找这个用户名是否已经被注册过了，如果已经被注册过了，则返回错误：“用户名已经注册”；如果没有被注册过，则新建一个user对象，将用户名和密码赋值进去，同时还要新建一个随机的哈希值，我们称之为token。token未来会作为该用户名的通行证，用于验证用户的身份。然后将新建的user对象插入到数据库之中，同时把token返回给客户端。

获取房间列表直接将房间map以JSON格式返回过去就行了。

删除房间需要传入一个参数：房间名。然后服务器判断，如果此房间名存在，则删除他；如果不存在，则返回错误：“删除失败”。

获取房间在线人数需要一个传入参数：房间名。如果房间存在，则返回房间的人数，如果不存在，则返回错误：”房间不存在“

WebSocket长连接用于客户端监听某个房间内的广播，是他能够随时接收到服务器发过来的消息。客户端的WebSocket连接成功之后，需要想服务器发生一条消息，用于指定你要监听的房间名。如果房间不存在，则新建一个并监听他。监听分为两个方向，一个是监听者的方向，比如这个监听者也想要在房间中发生消息的时候，这边就会收到消息，然后讲这个消息广播到房间中去；另一个方向是监听这个房间的广播，比如这个房间之中有其他人发消息的时候，就会收到消息，然后将这个消息发送给监听者即可。


## 客户端

客户端的设计主要分为三个页面：登录与注册页面、主页面和房间聊天页面。

登录与注册页面放在一个Activity里面，通过TabLayout来切换。登录的时候，输入用户名和密码，然后点击登录按钮即可；注册页面类似，但是增加一个再次输入密码的输入框，用于保证用户注册的密码输入的是正确的。

主界面分为三个部分：房间列表页面、个人页面和顶部的选择菜单。房间列表页面用于显示所有房间的列表，支持下拉刷新；个人页面用于显示用户的一些信息；顶部的选择菜单用于提供两个常用功能：创建房间和退出账号。

聊天界面由三部分组成：工具栏、聊天内容列表和输入栏。工具栏里面的标题用于显示一些房间的信息还有在线人数，工具栏里面的菜单还提供一个删除房间的按钮；聊天内容列表和其他的聊天软件一样，是一个将所有人发送出来的消息以一个反向的列表显示出来的可滑动页面，每当有用户在房间里面发送消息的时候，列表就会从底部添加一条消息；输入栏是用于用户输入消息的，包含一个输入框和一个发送按钮。

## 数据结构

数据结构的设计主要分为两个：User和Msg。

User用于存储用户的相关信息，里面包含三个字段：Username表示用户名，Password表示密码，Token表示用户的通行证。

Msg用于存储消息信息，包含两个字段：From表示消息来源，对应的是发送者User的Username；Content表示消息的具体内容，是一个string类型。

## 通讯协议

通讯协议主要是基于WebSocket技术，以WebSocket里面的JSON类型作为通讯协议。

JSON是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。

# 开发与实现

## 开发语言的选择

后端语言我们选择了目前比较火的Go语言。

Go是一个通用（General-Purpose）编程语言，这一点和C++以及Java是一致的。但通用不代表哪里都是最好，我们也要根据Go的特点来找到最适合Go的应用场景。Go的特点：编译：运行编译好的Go程序不需要额外安装像java的jdk或者js的node这样的运行环境，同时Go提供了原生的交叉编译支持，跨平台的开发和部署非常方便。当然编译运行也更容易带来更好的运行效率，不过这方面也不能迷信，越来越多的“解释型”编程语言的运行环境开始支持JIT，这让Go这种编译所带来的性能优势变得没有那么明显。静态类型：这对目前主流服务器端应用的项目规模来说，这是个很大优点，项目变得复杂时，能在编译期发现错误，总归比运行期发现来的简单。C家族语言：Go虽然吸收了很多现代编程语言的优点，但它主要还是可以看做是对C语言的继承和发展，又拒绝了c++中过于复杂的东西。对于日常编程，我们一般还是可以延续很多C语言的编程习惯的。GC：自动的垃圾回收对大多数服务器端项目来说是不可或缺的。这也是Go为什么能比Rust更早成为一个比较大众的编程语言的主要原因。

简单：简单是Go语言最根本的设计理念。简单到丑，你可以说是阉割了很多东西，你也可以说是和scala走向不同的极端。但有失就有得，我觉得在很多项目中，go这种简单直接的做法更加适合互联网行业快上快下的作风。工具包括godoc，包括code generation，包括test，benchmark，race-condition的检查，包括1.11中的Module等等，我觉得这部分是go最像一个现代编程语言的部分。依赖管理Go没有直接的类型继承，而是采用了一种隐性的继承方式。这样弱化类型继承带来的强耦合，由像“核心”模块代码依赖转变为每个模块向内依赖。这对于Google这种使用Monorepo的公司是非常有用的。有些朋友已经发现Go的编译速度特别快，即便是很大的项目，编译时间也不会指数级增长，其实也是得益于这种依赖的管理方式。所以我没把编译速度快这个这么重要的优点作为Go的特点，而是把依赖管理放在这里。

并发编程Go采用了和erlang很类似的方式来处理并发。我以前的回答中有讨论过channel和mailbox的不同，我觉得channel和协程更加灵活。但需要注意的是Go这种协程调度方式更加适合IO密集的应用服务，但对CPU密集的应用服务，可能会观察到部分请求响应时间略高（个人观察体会，其实也不是很大影响）。

泛型：Go 1.xx有限度的在数组，map和channel中支持泛型，我觉得可以有效的保证泛型不会被滥用。但这也招来了很多反对的声音，好多朋友都希望自己能够定义java和c#中的那种范型，那你只能等还在设计和开发中Go 2了。错误异常处理：这也是Go被诟病最多的地方，这方面很多文章了，我就不拾人牙慧了。我觉得的确是Go的Error处理是过于简单粗暴了一点，但也不是一无是处。这方面在Go2.0中也会通过check和handler来改进。生态：Go生来就是面向开源世界的语言，早先基于github的包管理，formater对于单一化tab的强制要求等等等等，让开源一个Go项目变得很舒服而且顺理成章。你要开源一个scala项目，估计要事先写上几天的代码风格指导书。对于一个新语言来说，go的生态是很让人惊叹的，这点也要着重感谢Uber等公司对自己Go代码的开源。总结：Go比C++要简单，比Java要轻，比Ruby/Python等要快，比Js/Php等工程性更好。这里不是说Go牛，只是Go更均衡，这让Go非常适合实现多数服务器端的业务逻辑。

客户端我们使用了安卓原生开发语言Java。

Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。

作为安卓的官方语言，因为官方支持好，性能高，所以我们选择了他，而不是Kotlin或者其他使用JavaScript开发的安卓框架。

## HTTP框架的选择

Go语言的HTTP框架众多，比较流行的有beego、gin、fasthttp等。你甚至可以自己根据标准库来轻松写一个自己的HTTP框架。这里我们选择的是Go语言里面性能最快的HTTP框架：fasthttp。我们选择他的主要原因还是因为速度快，性能好，内存占用小。

## WebSocket库

Go语言的WebSocket库，常用的有：官方维护的 golang.org/x/net/websocket、gorilla的 github.com/gorilla/websocket、还有fasthttp的 github.com/fasthttp/websocket。
这里因为我们已经选择使用了fasthttp作为http框架，所以我们只能选择fasthttp提供的websocket框架：github.com/fasthttp/websocket

Go语言的WebSocket库是依赖于HTTP协议的，他的路由过程和HTTP无异，但是在处理请求的时候，需要先把HTTP的请求，通过一个upgrader升级器来升级成为WebSocket协议。WebSocket里面支持多种消息类型，TextMessage、BinaryMessage、还有Ping Pong Message等。这里我们主要使用TextMessage，因为我们的通讯协议是基于JSON格式的，而JSON格式是以字符串方式传输的，所以我们使用TextMessage。

Android上面的WebSocket框架不是很多，目前我只找到一个好用的：org.java-websocket:Java-WebSocket 。使用起来也很方便。

新建一个URI对象，把WebSocket访问地址（以ws://开头）传进去。然后以此创建一个WebSocketClient对象，作为一个匿名类，我们直接在代码中实现它的几个重要的函数：onOpen()、onMessage()、还有onClose()和onError()函数。这三个函数分别代表了一个WebSocket连接的打开事件，收到消息事件和关闭事件，还有出错事件。在实现了以上4个函数之后，直接调用WebSocketClient的connect()函数即可开始连接了，非常简单。

## 订阅广播模式的实现

广播订阅模式是聊天室应用里面常用的一种组件。因为聊天室软件的消息模型是一对多的，所以一定是需要有一个能帮我们实现订阅和广播的组件的。我们一开始打算使用的是借助第三方软件来实现订阅广播的功能：redis虽然是一个基于key-value的数据库，但是他里面有一个订阅和广播的功能，非常符合我们的要求。但是使用的时候又需要再次引入第三方redis驱动，有一点太过繁琐，而且本项目的目的就是为了学习，所以我们打算自己实现一个简单的广播订阅模型：pubsub。

pubsub基于Go语言内置的通道组件channel来实现消息的发送。

pubsub订阅广播模型主要分为四个动作：订阅、广播、取消订阅和关闭。针对这四个动作，我们分别建立了对应的全局channel变量，他们分别是entering（chan Client类型）、messaging（chan Msg类型）、leaving（chan Client类型）和shutdown（chan bool类型）。

数据结构设计：Client数据结构用于存储订阅者的相关信息。里面包含一个chan interface{}类型用于订阅者接收消息，还有一个string类型的字段，用于存储该订阅者所订阅的主题；Msg数据结果表示消息，里面包含一个ChanID字段用于存储这条消息是要发给哪个主题的，还有一个Data字段（interface{}类型）用于存储消息的具体内容，interface{}类型可以存储任何类型的结构体。

广播管理器：广播管理器是pubsub里面的一个长期驻村在内存里面的线程，用于处理各个线程发来的广播消息。在管理器中，我们把所有的订阅者对象都保存在一个哈希Map里面，方便管理。然后使用Go语言里面的select字段，循环接收entering、messaging、leaving和shutdown四个管道里面发过来的消息：如果收到了entering管道的消息，则在map中添加一个Client对象；如果收到了messaging管道发来的消息，则把Msg中的ChanID字段取出来，在map中找到对应的主题，然后遍历这个主题中的所有订阅者，一个一个地给这些订阅者发送这条Msg；如果leaving管道发过来一条消息，则在对应map中，删除指定的Client对象即算是这个订阅者退出了订阅；如果shutdown管道发来消息，则把所有订阅者都对象都退出订阅并删除。

有了广播管理器之后，前面的四个操作实现起来就非常方便了：订阅操作发生的时候，先向entering管道发送一个新建的Client对象，然后开始监听这个Client对象的管道即可，如果有消息过来，广播管理器会帮我们处理的；取消订阅跟简单了，只需要将自己的Client对象发送到leaving管道即可；广播操作会新建一个Msg对象，然后把这个Msg对象发送到messaging管道里面去即可；关闭操作只需要向shutdown管道发送一个布尔类型true即可。

## Android开发框架

在Android开发框架上面我们选择了官方推荐的Android JetPack。
大体上，JetPack是Google推出的一些库的集合。是Android基础支持库SDK以外的部分。包含了组件、工具、架构方案等...开发者可以自主按需选择接入具体的哪个库。从Goole IO 2017开始。Google 开始推出Architecture Component, ORM库Room, 用户生命周期管理的ViewModel/ListData.Goole IO 2018将Support lib 更名为androidx. 将许多Google认为是正确的方案和实践集中起来。以高效的开发Android APP.以上种种，现在统称为JetPack. 其最核心的出发点就是帮助开发者快速构建出稳定、高性能、测试友好同时向后兼容的APP。2.组成部分前面讲到过，JetPack是一系列库和工具的集合，它更多是Google的一个提出的一个概念，或者说态度。并非所有的东西都是每年在IO大会上新推出的，它也包含了对现有基础库的整理和扩展。在大部分项目中其实我们都有用到JetPack的内容，也许你只是不知道而已。让我们以上帝视角来看看整个JetPack除了你熟悉的部分，还有哪些是你不熟悉但是听过的内容。看看他们都能做些什么事情。对于一些较少接触到的一些库我会提供一些第三方链接（CSDN、简书、掘金）作为拓展阅读，参考和学习。从官方的介绍来看。
JetPack总体包含四部分内容：
基础AppCompat，使得支持较低的Android版本。从以前继承Activity到现在继承AppCompatActivity 就是属于这一部分。
Android KTX，Kotlin的扩展支持库Multidex，多dex文件支持Test，测试支持库架构。
Data Binding，MVVM的一种实践。
Lifecycles，管理你的 Activity 和 Fragment 生命周期。
LiveData，通过观察者模式感知数据变化，类比RxJava。
Navigation，处理Fragment导航相关逻辑。
Paging，分页数据加载方案。
Room : 官方ORM库。
ViewModel : 通过数据驱动V视图发生改变。
WorkManager : 管理后台任务行为。
DownloadManager : 管理下载任务。
Media app ： 多媒体播放和一些向后兼容的API。主要包含MediaPalyer和ExoPlayer
Notifications : 提供向后兼容的通知 API，支持 Wear 和 Auto
Permissions : 权限管理，这个应该都接触过。用于检查和请求应用权限
Settings : Preference相关API。基本每个应用都会用到
Share Action : 提供分享操作。这块在国内使用的不多，都是自己封装或者采用第三方方案。
Slices : 可以让应用通过外部（其他APP）显示APP界面（通过设备自带的搜索，语音助手等）。
界面界面部分所包含的东西基本是我们接触的最多的了。
Animations and Transitions : 动画，界面转场等。
Auto : 针对车辆的标准化界面和模式。这方面实在接触的少，不感妄加评论。
Emoji : Emoji 相关。这个...同上面的Auto吧。
Fragment : 基础概念。
Layout : 基础概念。
Palette-Colors : 调色板。
TV : Android TV 开发相关。
Wear ： 可穿戴设备（目前主要是手表）开发相关

JetPack更多是一种概念和态度。相当于Google把自己的Android生态重新整理了一番。确立了Android未来的版图和大方向。所以我们才会选择这个这个框架。

## Android网络请求库

网络请求库我们使用了Google官方推荐的Volley。
所谓Volley,它是2013年Google I/O上发布的一款网络框架，基于Android平台，能使网络通信更快，更简单，更健全。

它的优点：（1）默认Android2.3及以上基于HttpURLConnection，2.3以下使用基于HttpClient；（2）符合Http 缓存语义 的缓存机制（提供了默认的磁盘和内存等缓存）；（3）请求队列的优先级排序；（4）提供多样的取消机制；（5）提供简便的图片加载工具（其实图片的加载才是我们最为看重的功能）；（6）一个优秀的框架。

不足之处也有：它只适合数据量小，通信频繁的网络操作，如果是数据量大的，像音频，视频等的传输，还是不要使用Volley的为好。

volley里面自带了很多的工具类，像StringRequest,JsonArrayRequest,JsonObjectRequest,ImageRequest这些都是我们平时经常使用的http请求，我们就可以直接把它们拿过来用。

如果你的应用需要频繁地发送请求网络，那么你最高效的方式是创建一个请求队列的单例，而且他要长期存在于app的整个生命周期之中。你可以通过很多种方式来实现这个东西，当然，最推荐的做法就是实现一个Singleton的类，里面要包含一个请求队列和一些其他的Volley相关的工具函数。另一个做法是继承Application然后在Application类里面的onCreate函数中对请求队列进行设置，但是这个实现方法是非常不推荐的，因为前者可以以更加模块化的方式实现相同的功能。

有一个关键的地方是RequestQueue必须在初始化的时候传入Application的Context，而不是Activity的Context。这样就能保证RequestQueue是长期存在于整个App的生命周期之中的，而不是每次换了一个新的Activity，RequestQueue就重新启动一次，比如当你翻转手机的时候，会重新绘制整个Activity。

在我们这个项目当中，我们主要使用的是JsonObjectRequest，因为我们大部分接口返回的都是JSON数据格式。

# 总结



# 参考文献

# 致谢

# 外文原文

# 中文翻译